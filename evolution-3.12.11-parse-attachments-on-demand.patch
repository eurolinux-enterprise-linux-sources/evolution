diff -up evolution-3.12.11/em-format/e-mail-formatter-attachment.c.parse-attachments-on-demand evolution-3.12.11/em-format/e-mail-formatter-attachment.c
--- evolution-3.12.11/em-format/e-mail-formatter-attachment.c.parse-attachments-on-demand	2014-03-24 10:25:23.000000000 +0100
+++ evolution-3.12.11/em-format/e-mail-formatter-attachment.c	2015-08-19 16:17:57.887545211 +0200
@@ -335,13 +335,29 @@ emfe_attachment_format (EMailFormatterEx
 			g_string_append_printf (
 				buffer,
 				"<tr><td colspan=\"2\">"
-				"<div class=\"attachment-wrapper\" id=\"%s\">",
+				"<div class=\"attachment-wrapper\" id=\"%s\"",
 				wrapper_element_id);
 
-			g_string_append_len (buffer, data, size);
+			if (e_mail_part_should_show_inline (part)) {
+				g_string_append (buffer, ">");
+				g_string_append_len (buffer, data, size);
+			} else {
+				gchar *inner_html_data;
+
+				inner_html_data = g_markup_escape_text (data, size);
+
+				g_string_append_printf (
+					buffer,
+					" inner-html-data=\"%s\">",
+					inner_html_data);
+
+				g_free (inner_html_data);
+			}
 
 			g_string_append (buffer, "</div></td></tr>");
 
+			e_mail_part_attachment_set_expandable (empa, TRUE);
+
 			g_free (wrapper_element_id);
 		}
 
diff -up evolution-3.12.11/em-format/e-mail-part-attachment.c.parse-attachments-on-demand evolution-3.12.11/em-format/e-mail-part-attachment.c
--- evolution-3.12.11/em-format/e-mail-part-attachment.c.parse-attachments-on-demand	2014-07-17 12:48:14.000000000 +0200
+++ evolution-3.12.11/em-format/e-mail-part-attachment.c	2015-08-19 16:16:41.520548446 +0200
@@ -23,11 +23,13 @@
 
 struct _EMailPartAttachmentPrivate {
 	EAttachment *attachment;
+	gboolean expandable;
 };
 
 enum {
 	PROP_0,
-	PROP_ATTACHMENT
+	PROP_ATTACHMENT,
+	PROP_EXPANDABLE
 };
 
 G_DEFINE_TYPE (
@@ -36,6 +38,23 @@ G_DEFINE_TYPE (
 	E_TYPE_MAIL_PART)
 
 static void
+mail_part_attachment_set_property (GObject *object,
+				   guint property_id,
+				   const GValue *value,
+				   GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_EXPANDABLE:
+			e_mail_part_attachment_set_expandable (
+				E_MAIL_PART_ATTACHMENT (object),
+				g_value_get_boolean (value));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
 mail_part_attachment_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
@@ -48,6 +67,13 @@ mail_part_attachment_get_property (GObje
 				e_mail_part_attachment_ref_attachment (
 				E_MAIL_PART_ATTACHMENT (object)));
 			return;
+
+		case PROP_EXPANDABLE:
+			g_value_set_boolean (
+				value,
+				e_mail_part_attachment_get_expandable (
+				E_MAIL_PART_ATTACHMENT (object)));
+			return;
 	}
 
 	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -125,6 +151,7 @@ e_mail_part_attachment_class_init (EMail
 
 	object_class = G_OBJECT_CLASS (class);
 	object_class->get_property = mail_part_attachment_get_property;
+	object_class->set_property = mail_part_attachment_set_property;
 	object_class->dispose = mail_part_attachment_dispose;
 	object_class->finalize = mail_part_attachment_finalize;
 	object_class->constructed = mail_part_attachment_constructed;
@@ -139,12 +166,24 @@ e_mail_part_attachment_class_init (EMail
 			E_TYPE_ATTACHMENT,
 			G_PARAM_READABLE |
 			G_PARAM_STATIC_STRINGS));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_EXPANDABLE,
+		g_param_spec_boolean (
+			"expandable",
+			"Expandable",
+			"Whether the attachment can be expanded",
+			FALSE,
+			G_PARAM_READWRITE |
+			G_PARAM_STATIC_STRINGS));
 }
 
 static void
 e_mail_part_attachment_init (EMailPartAttachment *part)
 {
 	part->priv = E_MAIL_PART_ATTACHMENT_GET_PRIVATE (part);
+	part->priv->expandable = FALSE;
 }
 
 EMailPartAttachment *
@@ -166,3 +205,24 @@ e_mail_part_attachment_ref_attachment (E
 	return g_object_ref (part->priv->attachment);
 }
 
+void
+e_mail_part_attachment_set_expandable (EMailPartAttachment *part,
+				       gboolean expandable)
+{
+	g_return_if_fail (E_IS_MAIL_PART_ATTACHMENT (part));
+
+	if ((part->priv->expandable ? 1 : 0) == (expandable ? 1 : 0))
+		return;
+
+	part->priv->expandable = expandable;
+
+	g_object_notify (G_OBJECT (part), "expandable");
+}
+
+gboolean
+e_mail_part_attachment_get_expandable (EMailPartAttachment *part)
+{
+	g_return_val_if_fail (E_IS_MAIL_PART_ATTACHMENT (part), FALSE);
+
+	return part->priv->expandable;
+}
diff -up evolution-3.12.11/em-format/e-mail-part-attachment.h.parse-attachments-on-demand evolution-3.12.11/em-format/e-mail-part-attachment.h
--- evolution-3.12.11/em-format/e-mail-part-attachment.h.parse-attachments-on-demand	2014-03-24 10:25:23.000000000 +0100
+++ evolution-3.12.11/em-format/e-mail-part-attachment.h	2015-08-19 16:16:41.521548446 +0200
@@ -68,6 +68,11 @@ EMailPartAttachment *
 						 const gchar *id);
 EAttachment *	e_mail_part_attachment_ref_attachment
 						(EMailPartAttachment *part);
+void		e_mail_part_attachment_set_expandable
+						(EMailPartAttachment *part,
+						 gboolean expandable);
+gboolean	e_mail_part_attachment_get_expandable
+						(EMailPartAttachment *part);
 
 G_END_DECLS
 
diff -up evolution-3.12.11/em-format/e-mail-part.c.parse-attachments-on-demand evolution-3.12.11/em-format/e-mail-part.c
--- evolution-3.12.11/em-format/e-mail-part.c.parse-attachments-on-demand	2015-08-19 16:17:48.230545620 +0200
+++ evolution-3.12.11/em-format/e-mail-part.c	2015-08-19 16:17:57.887545211 +0200
@@ -26,10 +26,15 @@
  * message.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "e-mail-part.h"
 
 #include <string.h>
 
+#include "e-mail-part-attachment.h"
 #include "e-mail-part-list.h"
 
 #define E_MAIL_PART_GET_PRIVATE(obj) \
@@ -441,6 +446,46 @@ e_mail_part_set_mime_type (EMailPart *pa
 	g_object_notify (G_OBJECT (part), "mime-type");
 }
 
+gboolean
+e_mail_part_should_show_inline (EMailPart *part)
+{
+	CamelMimePart *mime_part;
+	const CamelContentDisposition *disposition;
+	gboolean res = FALSE;
+
+	g_return_val_if_fail (E_IS_MAIL_PART (part), FALSE);
+
+	/* Automatically expand attachments that have inline
+	 * disposition or the EMailParts have specific
+	 * force_inline flag set. */
+
+	if (part->force_collapse)
+		return FALSE;
+
+	if (part->force_inline)
+		return TRUE;
+
+	if (E_IS_MAIL_PART_ATTACHMENT (part)) {
+		EMailPartAttachment *empa = E_MAIL_PART_ATTACHMENT (part);
+
+		if (g_strcmp0 (empa->snoop_mime_type, "message/rfc822") == 0)
+			return TRUE;
+	}
+
+	mime_part = e_mail_part_ref_mime_part (part);
+	if (!mime_part)
+		return FALSE;
+
+	disposition = camel_mime_part_get_content_disposition (mime_part);
+	if (disposition && disposition->disposition &&
+	    g_ascii_strncasecmp (disposition->disposition, "inline", 6) == 0)
+		res = TRUE;
+
+	g_object_unref (mime_part);
+
+	return res;
+}
+
 EMailPartList *
 e_mail_part_ref_part_list (EMailPart *part)
 {
diff -up evolution-3.12.11/em-format/e-mail-part.h.parse-attachments-on-demand evolution-3.12.11/em-format/e-mail-part.h
--- evolution-3.12.11/em-format/e-mail-part.h.parse-attachments-on-demand	2015-08-19 16:17:41.783545893 +0200
+++ evolution-3.12.11/em-format/e-mail-part.h	2015-08-19 16:17:57.887545211 +0200
@@ -107,6 +107,7 @@ CamelMimePart *	e_mail_part_ref_mime_par
 const gchar *	e_mail_part_get_mime_type	(EMailPart *part);
 void		e_mail_part_set_mime_type	(EMailPart *part,
 						 const gchar *mime_type);
+gboolean	e_mail_part_should_show_inline	(EMailPart *part);
 struct _EMailPartList *
 		e_mail_part_ref_part_list	(EMailPart *part);
 void		e_mail_part_set_part_list	(EMailPart *part,
diff -up evolution-3.12.11/mail/e-mail-display.c.parse-attachments-on-demand evolution-3.12.11/mail/e-mail-display.c
--- evolution-3.12.11/mail/e-mail-display.c.parse-attachments-on-demand	2014-06-18 14:11:40.000000000 +0200
+++ evolution-3.12.11/mail/e-mail-display.c	2015-08-19 16:17:57.888545210 +0200
@@ -459,6 +459,23 @@ attachment_button_expanded (GObject *obj
 		return;
 	}
 
+	if (WEBKIT_DOM_IS_HTML_ELEMENT (element) && expanded &&
+	    webkit_dom_element_get_child_element_count (element) == 0) {
+		gchar *inner_html_data;
+
+		inner_html_data = webkit_dom_element_get_attribute (element, "inner-html-data");
+		if (inner_html_data && *inner_html_data) {
+			WebKitDOMHTMLElement *html_element;
+
+			html_element = WEBKIT_DOM_HTML_ELEMENT (element);
+			webkit_dom_html_element_set_inner_html (html_element, inner_html_data, NULL);
+
+			webkit_dom_element_remove_attribute (element, "inner-html-data");
+		}
+
+		g_free (inner_html_data);
+	}
+
 	/* Show or hide the DIV which contains
 	 * the attachment (iframe, image...). */
 	css = webkit_dom_element_get_style (element);
@@ -644,37 +661,12 @@ mail_display_plugin_widget_requested (We
 		/* Bind visibility of DOM element containing related
 		 * attachment with 'expanded' property of this
 		 * attachment button. */
-		WebKitDOMElement *attachment;
-		WebKitDOMDocument *document;
 		EMailPartAttachment *empa = (EMailPartAttachment *) part;
-		gchar *attachment_part_id;
-		gchar *wrapper_element_id;
-
-		if (empa->attachment_view_part_id)
-			attachment_part_id = empa->attachment_view_part_id;
-		else
-			attachment_part_id = part_id;
 
-		/* Find attachment-wrapper div which contains
-		 * the content of the attachment (iframe). */
-		document = webkit_web_view_get_dom_document (
-			WEBKIT_WEB_VIEW (display));
-		wrapper_element_id = g_strconcat (
-			attachment_part_id, ".wrapper", NULL);
-		attachment = find_element_by_id (document, wrapper_element_id);
-		g_free (wrapper_element_id);
-
-		/* None found? Attachment cannot be expanded */
-		if (attachment == NULL) {
-			e_attachment_button_set_expandable (
-				E_ATTACHMENT_BUTTON (widget), FALSE);
-		} else {
-			CamelMimePart *mime_part;
-			const CamelContentDisposition *disposition;
-
-			e_attachment_button_set_expandable (
-				E_ATTACHMENT_BUTTON (widget), TRUE);
+		e_attachment_button_set_expandable (E_ATTACHMENT_BUTTON (widget),
+			e_mail_part_attachment_get_expandable (empa));
 
+		if (e_mail_part_attachment_get_expandable (empa)) {
 			/* Show/hide the attachment when the EAttachmentButton
 			 * is expanded/collapsed or shown/hidden. */
 			g_signal_connect (
@@ -686,20 +678,7 @@ mail_display_plugin_widget_requested (We
 				G_CALLBACK (attachment_button_expanded),
 				display);
 
-			mime_part = e_mail_part_ref_mime_part (part);
-
-			/* Automatically expand attachments that have inline
-			 * disposition or the EMailParts have specific
-			 * force_inline flag set. */
-			disposition =
-				camel_mime_part_get_content_disposition (mime_part);
-			if (!part->force_collapse &&
-			    (part->force_inline ||
-			    (g_strcmp0 (empa->snoop_mime_type, "message/rfc822") == 0) ||
-			     (disposition && disposition->disposition &&
-				g_ascii_strncasecmp (
-					disposition->disposition, "inline", 6) == 0))) {
-
+			if (e_mail_part_should_show_inline (part)) {
 				e_attachment_button_set_expanded (
 					E_ATTACHMENT_BUTTON (widget), TRUE);
 			} else {
@@ -708,8 +687,6 @@ mail_display_plugin_widget_requested (We
 				attachment_button_expanded (
 					G_OBJECT (widget), NULL, display);
 			}
-
-			g_object_unref (mime_part);
 		}
 	}
 
